#pragma config(Motor,  port2,           motorLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           motorRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           motorOmni,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           motorSuc,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           motorLiftFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           motorLiftBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           motorShotRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           motorShotLeft, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/*******************************************************************************************************************************************
el programa esta enfocado en ahorrar memoria y que ejecute el programa con una complejidad minima para ser mas rapido el tiempo de respuesta
cada que declaras una variable global, un gatito muere y eso no esta pro :(
el programa simula programacion orientada a objetos (da un orden al programa)
el programa esta con punteros para ahorrar memoria
algunas palabras estan en ingles por que las palabras en ingles estan mas cortas
********************************************************************************************************************************************/

//constantes para poder hacer cambios mas rapido
#define MAX 100

#define FRONTRIGHT -1 //estas variables sirven de por si el motor va al reves entonces solo poner el contrario y ya
#define FRONTLEFT 1
#define FRONTOMNI 1
#define FRONTSUC 1
#define FRONTLIFTFRONT 1
#define FRONTLIFTBACK 1
#define FRONTSHOTRIGHT -1 //por ejemplo si un motor al poner que valla hacia adelante y va hacia atras se pone -1
#define FRONTSHOTLEFT 1 //es mejor cambiarlo asi que por hardware por que si se desconecta no tenemos que batallar ya que conectamos rojo con rojo :)

#define ADELANTE_D Btn5D //defino los botones para en caso de querer cambiar los botones, cambiarlo mas facil
#define ATRAS_D Btn5U    //ademas sirve mucho para poder ver las convinaciones
#define ADELANTE_I Btn6D //y se ve mas organizado el programa
#define ATRAS_I Btn6U
#define IZQUIERDA Btn7L
#define DERECHA Btn8R
#define SUCCIONAR Btn8D
#define ESCUPIR Btn8U
#define ELEVAR Btn7U
#define BAJAR Btn7D
#define DISPARO Btn7R
#define APAGARBANDA Btn8L

//"clase" motores (utilizar cada motor como si fuera un objeto para que sea mas facil cambiar algo del programa)
struct motor393{ //estructura de los motores para poder hacer cosas mas facil
	short speed;
	short front;
	short port;
};
void newMotor(motor393 *m, short front, int port){ //funcion que "crea" un motor
	m->speed= MAX;
	m->front= front;
	m->port= (short)port;
}
void motorFront(motor393 *m){//los motores son tratados con punteros para ahorrar memoria
	motor[m->port]=m->front*m->speed; //el motor del puerto guardado en port de m va a ir a la velocidad multiplicado por 1 o -1(para que varie la orientacion)
}
void motorBack(motor393 *m){
	motor[m->port]=-(m->front*m->speed);
}
void motorStop(motor393 *m){
	motor[m->port]=0;
}
void motorSetSpeed(motor393 *m, short speed){ //le da velocidad al motor
	m->speed=speed; //dale velocidad a un motor desde un metoro diferente hace que el codigo sea mas entendible y en algunos casos solo se neceesita cambiar la velocidad
}

//movimientos
void startSpeed(motor393 *motor_){ //define velocidades de los motores
	motorSetSpeed(&motor_[motorRight], MAX);
	motorSetSpeed(&motor_[motorLeft], MAX);
	motorSetSpeed(&motor_[motorOmni], 100);
	motorSetSpeed(&motor_[motorSuc], 100);
	motorSetSpeed(&motor_[motorLiftFront], 120);
	motorSetSpeed(&motor_[motorLiftBack], 120);
	motorSetSpeed(&motor_[motorShotRight], 100);
	motorSetSpeed(&motor_[motorShotLeft], 100);
}
void up(motor393 *motor1, motor393 *motor2){ //funciones que sirven para controlar dos motores
	motorFront(motor1);
	motorFront(motor2);
}
void down(motor393 *motor1, motor393 *motor2){
	motorBack(motor1);
	motorBack(motor2);
}
void stopLift(motor393 *motor1, motor393 *motor2){
	motorStop(motor1);
	motorStop(motor2);
}
void front(motor393 *motor_){
     motorFront(&motor_[motorRight]);
     motorFront(&motor_[motorLeft]);
}
void back(motor393 *motor_){
     motorBack(&motor_[motorRight]);
     motorBack(&motor_[motorLeft]);
}
void turnback(motor393 *motor_){
     motorBack(&motor_[motorRight]);
     motorStop(&motor_[motorLeft]);
     delay(300);
}
void stopRobot(motor393 *motor_){
     motorStop(&motor_[motorRight]);
     motorStop(&motor_[motorLeft]);
}
void shotSet(int speed){
		motor[motorShotRight]=speed*FRONTSHOTRIGHT;
		motor[motorShotLeft]=speed*FRONTSHOTLEFT;
}
task shot(){//tarea que va a correr de forma paralela para controlar los motores de disparo con oscilamiento
	int il;
	while(true){
		for(il=60; il<70; il++){
			shotSet(il);
		}
		shotSet(70);
		wait10Msec(1000);
		shotSet(20);
		wait10Msec(30);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void initialize(motor393 *_motor, short *fronts, short *ports){ //le doy los valores a los motores
	for(short i=0; i<10; i++)
		newMotor(&_motor[i], fronts[i], ports[i]); //crea un motor
}
void pre_auton()
{
	motor393 _motor[10];//declaro los motores
	//declaro arreglos para darle valores a los motores
	short fronts[10]={1, FRONTLEFT, FRONTRIGHT, FRONTOMNI, FRONTSUC, FRONTLIFTFRONT, FRONTLIFTBACK, FRONTSHOTRIGHT, FRONTSHOTLEFT, 1};
	short ports[10]={0,motorLeft,motorRight,motorOmni,motorSuc,motorLiftFront,motorLiftBack,motorShotRight,motorShotLeft,0};
	initialize(&_motor[0], &fronts[0], &ports[0]);//le doy valores a los motores
	startSpeed(&_motor[0]); //inicializo las velocidades de los motores
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	motor393 motor_[10];//declaro los motores
	short fronts[10]={1, FRONTLEFT, FRONTRIGHT, FRONTOMNI, FRONTSUC, FRONTLIFTFRONT, FRONTLIFTBACK, FRONTSHOTRIGHT, FRONTSHOTLEFT, 1};
	short ports[10]={0,motorLeft,motorRight,motorOmni,motorSuc,motorLiftFront,motorLiftBack,motorShotRight,motorShotLeft,0};
	initialize(&motor_[0], &fronts[0], &ports[0]);
	startSpeed(&motor_[0]);
	up(&motor_[motorShotRight], &motor_[motorShotLeft]);
	front(motor_);
	delay(8000);
	stopRobot(motor_);
	motorFront(&motor_[motorSuc]);
	delay(2000);
	stopLift(&motor_[motorShotRight], &motor_[motorShotLeft]);
	back(motor_);
	delay(500);
  turnback(motor_);
  delay(2600);
  while(true){
		stopLift(&motor_[motorShotRight], &motor_[motorShotLeft]);
		front(motor_);
  }
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

//control
void controlMov(motor393 *motor_){ //checa los botones de los motores

	if(vexRT[ADELANTE_D]){//depende de que boton este presionado entonces mueve el motor de diferente forma
		motorFront(&motor_[motorLeft]);
	}
	else if(vexRT[ATRAS_D]){
		motorBack(&motor_[motorLeft]);
	}
	else {
		motorStop(&motor_[motorLeft]);//en caso de que ningun boton esta presionado, entonces apaga el motor
	}

	if(vexRT[ADELANTE_I]){ //lo mismo que arriba pero con el boton izquierdo
		motorFront(&motor_[motorRight]);
	}
	else if(vexRT[ATRAS_I]){
		motorBack(&motor_[motorRight]);
	}
	else {
		motorStop(&motor_[motorRight]);
	}

	if(vexRT[IZQUIERDA]){ //lo mismo que arriba pero con el boton izquierdo
		motorFront(&motor_[motorOmni]);
	}
	else if(vexRT[DERECHA]){
		motorBack(&motor_[motorOmni]);
	}
	else {
		motorStop(&motor_[motorOmni]);
	}

}
void controlBandas(motor393 *motor_){ //funcion que controla las bandas

	if(vexRT[SUCCIONAR]){
		motorFront(&motor_[motorSuc]);
	}
	else if(vexRT[ESCUPIR]){
		motorBack(&motor_[motorSuc]);
	}
	else if(vexRT[APAGARBANDA]){
		motorStop(&motor_[motorSuc]);
	}

}
void controlElevador(motor393 *motor_){ //funcion que controla los elevadores del robot

	if(vexRT[ELEVAR]){
		up(&motor_[motorLiftFront], &motor_[motorLiftBack]);
	}
	else if(vexRT[BAJAR]){
		down(&motor_[motorLiftFront], &motor_[motorLiftBack]);
	}
	else stopLift(&motor_[motorLiftFront], &motor_[motorLiftBack]);

}
bool controlShot(motor393 *motor_, bool dis){ //funcion que controla los disparadores
	if(vexRT[DISPARO] && dis){
		startTask(shot); //llamo la tarea que controla los disparadores para que funcione de forma paralela a main
		dis=false;
		waitUntil(!vexRT[DISPARO]);//espera hasta que suelte el boton
	}
	else if(vexRT[DISPARO]){
		stopTask(shot);//detengo el oscilamiento
		stopLift(&motor_[motorShotRight], &motor_[motorShotLeft]); //detengo los motores
		dis=true;
		waitUntil(!vexRT[DISPARO]);//espera hasta que suelte el boton
	}
	return dis;
}
task usercontrol()
{
	motor393 _motor[10];//declaro los motores
	short fronts[10]={1, FRONTLEFT, FRONTRIGHT, FRONTOMNI, FRONTSUC, FRONTLIFTFRONT, FRONTLIFTBACK, FRONTSHOTRIGHT, FRONTSHOTLEFT, 1};
	short ports[10]={0,motorLeft,motorRight,motorOmni,motorSuc,motorLiftFront,motorLiftBack,motorShotRight,motorShotLeft,0};
	initialize(&_motor[0], &fronts[0], &ports[0]);
	startSpeed(&_motor[0]);
	bool dis=true;
	while(true){
		controlMov(&_motor[0]); //checa las teclas de los movimientos
		controlBandas(&_motor[0]); //checa el control de las bandas
		controlElevador(&_motor[0]); //checa el control del elevador
		dis=controlShot(&_motor[0], dis); //checa el control de las disparadoras
	}
}
