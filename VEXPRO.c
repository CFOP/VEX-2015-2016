#pragma config(Motor,  port2,           motorLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           motorRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           motorUp,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           motorSuc,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           motorLiftFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           motorLiftBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           motorShotRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           motorShotLeft, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/*******************************************************************************************************************************************
el programa esta enfocado en ahorrar memoria y que ejecute el programa con una complejidad minima para ser mas rapido el tiempo de respuesta
cada que declaras una variable global, un gatito muere y eso no esta pro :(
el programa simula programacion orientada a objetos (da un orden al programa)
el programa esta con punteros para ahorrar memoria
algunas palabras estan en ingles por que las palabras en ingles estan mas cortas
********************************************************************************************************************************************/

//constantes para poder hacer cambios mas rapido
#define MAX 100

#define FRONTRIGHT -1 //estas variables sirven de por si el motor va al reves entonces solo poner el contrario y ya
#define FRONTLEFT 1
#define FRONTUP 1
#define FRONTSUC 1
#define FRONTLIFTFRONT 1
#define FRONTLIFTBACK 1
#define FRONTSHOTRIGHT -1 //por ejemplo si un motor al poner que valla hacia adelante y va hacia atras se pone -1
#define FRONTSHOTLEFT 1 //es mejor cambiarlo asi que por hardware por que si se desconecta no tenemos que batallar ya que conectamos rojo con rojo :)

#define ADELANTE_D Btn6D //defino los botones para en caso de querer cambiar los botones, cambiarlo mas facil
#define ATRAS_D Btn6U    //ademas sirve mucho para poder ver las convinaciones
#define ADELANTE_I Btn5D //y se ve mas organizado el programa
#define ATRAS_I Btn5U
#define SUCCIONAR Btn8D
#define ESCUPIR Btn8R
#define SUBIR Btn8L //SUBIR PELOTA
#define ELEVAR Btn7U
#define BAJAR Btn7D
#define DISPARO Btn7L
#define APAGARBANDA Btn8U

//"clase" motores (utilizar cada motor como si fuera un objeto para que sea mas facil cambiar algo del programa)
struct motor393{ //estructura de los motores para poder hacer cosas mas facil
	short speed;
	short front;
	short port;
};
void newMotor(motor393 *m, short front, int port){ //funcion que "crea" un motor
	m->speed= MAX;
	m->front= front;
	m->port= (short)port;
}
void motorFront(motor393 *m){//los motores son tratados con punteros para ahorrar memoria
	motor[m->port]=m->front*m->speed; //el motor del puerto guardado en port de m va a ir a la velocidad multiplicado por 1 o -1(para que varie la orientacion)
}
void motorBack(motor393 *m){
	motor[m->port]=-(m->front*m->speed);
}
void motorStop(motor393 *m){
	motor[m->port]=0;
}
void motorSetSpeed(motor393 *m, short speed){ //le da velocidad al motor
	m->speed=speed; //dale velocidad a un motor desde un metoro diferente hace que el codigo sea mas entendible y en algunos casos solo se neceesita cambiar la velocidad
}

//movimientos
bool getUp(motor393 *motor_, bool g){ //funcion booleana que controla la banda para ssubir la pelota
	if(g){
		motorFront(&motor_[motorUp]); //en caso de que "g" sea verdadero entonces avanza
	}
	else {
		motorStop(&motor_[motorUp]);  //si no, retrocede
	}
	return !g; //regresa lo contrario pues se hizo un cambio
}
void startSpeed(motor393 *motor_){ //define velocidades de los motores
	motorSetSpeed(&motor_[motorRight], 100);
	motorSetSpeed(&motor_[motorLeft], 100);
	motorSetSpeed(&motor_[motorSuc], 100);
	motorSetSpeed(&motor_[motorUp], 100);
	motorSetSpeed(&motor_[motorLiftFront], 120);
	motorSetSpeed(&motor_[motorLiftBack], 120);
	motorSetSpeed(&motor_[motorShotRight], 100);
	motorSetSpeed(&motor_[motorShotLeft], 100);
}
void up(motor393 *motor1, motor393 *motor2){ //funciones que sirven para controlar dos motores
	motorFront(motor1);
	motorFront(motor2);
}
void down(motor393 *motor1, motor393 *motor2){
	motorBack(motor1);
	motorBack(motor2);
}
void stopLift(motor393 *motor1, motor393 *motor2){
	motorStop(motor1);
	motorStop(motor2);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

motor393 *mot;//aqui declaro una variable global porque no encontre otra forma de mandar la direccion de los motores a la tarea del control

void initialize(motor393 *_motor, short *fronts, short *ports){ //le doy los valores a los motores
	for(short i=0; i<10; i++)
		newMotor(&_motor[i], fronts[i], ports[i]); //crea un motor
}
void pre_auton()
{
	motor393 _motor[10];//declaro los motores
	//declaro arreglos para darle valores a los motores
	short fronts[10]={1, FRONTLEFT, FRONTRIGHT, FRONTUP, FRONTSUC, FRONTLIFTFRONT, FRONTLIFTBACK, FRONTSHOTRIGHT, FRONTSHOTLEFT, 1};
	short ports[10]={0,motorLeft,motorRight,motorUp,motorSuc,motorLiftFront,motorLiftBack,motorShotRight,motorShotLeft,0};
	initialize(&_motor[0], &fronts[0], &ports[0]);//le doy valores a los motores
	startSpeed(&_motor[0]); //inicializo las velocidades de los motores
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	motor393 *_motor=mot;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

//control
void controlMov(motor393 *motor_){ //checa los botones de los motores

	if(vexRT[ADELANTE_D]){//depende de que boton este presionado entonces mueve el motor de diferente forma
		motorFront(&motor_[motorLeft]);
	}
	else if(vexRT[ATRAS_D]){
		motorBack(&motor_[motorLeft]);
	}
	else {
		motorStop(&motor_[motorLeft]);//en caso de que ningun boton esta presionado, entonces apaga el motor
	}

	if(vexRT[ADELANTE_I]){ //lo mismo que arriba pero con el boton izquierdo
		motorFront(&motor_[motorRight]);
	}
	else if(vexRT[ATRAS_I]){
		motorBack(&motor_[motorRight]);
	}
	else {
		motorStop(&motor_[motorRight]);
	}

}
bool controlBandas(motor393 *motor_, bool g){ //funcion que controla las bandas

	if(vexRT[SUCCIONAR]){
		motorFront(&motor_[motorSuc]);
	}
	else if(vexRT[ESCUPIR]){
		motorBack(&motor_[motorSuc]);
	}
	else if(vexRT[APAGARBANDA]){
		motorStop(&motor_[motorSuc]);
	}

	if(vexRT[SUBIR]){
		getUp(motor_, g);
		g=!g;
		waitUntil(!vexRT[SUBIR]);//espera hasta que suelte el motor
	}
	return g; //la funcion es booleana por que necesita retornar una variable que le da getUp

}
void controlElevador(motor393 *motor_){ //funcion que controla los elevadores del robot

	if(vexRT[ELEVAR]){
		up(&motor_[motorLiftFront], &motor_[motorLiftBack]);
	}
	else if(vexRT[BAJAR]){
		down(&motor_[motorLiftFront], &motor_[motorLiftBack]);
	}
	else stopLift(&motor_[motorLiftFront], &motor_[motorLiftBack]);

}

bool controlShot(motor393 *motor_, bool dis){ //funcion que controla los disparadores
	if(vexRT[DISPARO] && dis){
		up(&motor_[motorShotRight], &motor_[motorShotLeft]);
		dis=false;
		waitUntil(!vexRT[DISPARO]);//espera hasta que suelte el motor
	}
	else if(vexRT[DISPARO]){
		stopLift(&motor_[motorShotRight], &motor_[motorShotLeft]);
		dis=true;
		waitUntil(!
		vexRT[DISPARO]);//espera hasta que suelte el motor
	}
	return dis;
}

task usercontrol()
{
	motor393 *_motor=mot;
	bool subir=true;
	bool dis=true;
	while(true){
		controlMov(&_motor[0]); //checa las teclas de los movimientos
		subir=controlBandas(&_motor[0], subir); //checa el control de las bandas
		controlElevador(&_motor[0]); //checa el control del elevador
		dis=controlShot(&_motor[0], dis); //checa el control de las disparadoras
	}
}
